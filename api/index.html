<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Spencer Lyon">
        
        <link rel="shortcut icon" href="../../favicon.ico">
        

	<title>Overview - QuantEcon.jl</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-64434120-1', 'auto');
            ga('send', 'pageview');
        </script>
        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">QuantEcon.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Overview</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Docs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="QuantEcon/">QuantEcon</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="QuantEcon/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/QuantEcon/QuantEcon.jl/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#api-index">API-INDEX</a></li>
        
            <li><a href="#module-quantecon">MODULE: QuantEcon</a></li>
        
            <li><a href="#functions-exported">Functions [Exported]</a></li>
        
            <li><a href="#methods-exported">Methods [Exported]</a></li>
        
            <li><a href="#types-exported">Types [Exported]</a></li>
        
            <li><a href="#methods-internal">Methods [Internal]</a></li>
        
            <li><a href="#types-internal">Types [Internal]</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="api-index">API-INDEX</h1>
<h2 id="module-quantecon">MODULE: QuantEcon</h2>
<hr />
<h2 id="functions-exported">Functions [Exported]</h2>
<p><a href="QuantEcon/#function__do_quad.1">QuantEcon.do_quad</a>  Approximate the integral of <code>f</code>, given quadrature <code>nodes</code> and <code>weights</code></p>
<p><a href="QuantEcon/#function__ecdf.1">QuantEcon.ecdf</a>  Evaluate the empirical cdf at one or more points</p>
<p><a href="QuantEcon/#function__periodogram.1">QuantEcon.periodogram</a>  Computes the periodogram</p>
<p><a href="QuantEcon/#function__simulate_values.1">QuantEcon.simulate_values</a>   Like <code>simulate(::MarkovChain, args...; kwargs...)</code>, but instead of</p>
<p><a href="QuantEcon/#function__simulate_values.2">QuantEcon.simulate_values!</a>   Like <code>simulate(::MarkovChain, args...; kwargs...)</code>, but instead of</p>
<hr />
<h2 id="methods-exported">Methods [Exported]</h2>
<p><a href="QuantEcon/#method__f_to_k.1">F_to_K(rlq::QuantEcon.RBLQ,  F::Array{T, 2})</a>  Compute agent 2's best cost-minimizing response <code>K</code>, given <code>F</code>.</p>
<p><a href="QuantEcon/#method__k_to_f.1">K_to_F(rlq::QuantEcon.RBLQ,  K::Array{T, 2})</a>  Compute agent 1's best cost-minimizing response <code>K</code>, given <code>F</code>.</p>
<p><a href="QuantEcon/#method__rq_sigma.1">RQ_sigma(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real})</a>  Method of <code>RQ_sigma</code> that extracts sigma from a <code>DPSolveResult</code></p>
<p><a href="QuantEcon/#method__rq_sigma.2">RQ_sigma{T&lt;:Integer}(ddp::QuantEcon.DiscreteDP{T, 3, 2, Tbeta, Tind},  sigma::Array{T&lt;:Integer, N})</a>  Given a policy <code>sigma</code>, return the reward vector <code>R_sigma</code> and</p>
<p><a href="QuantEcon/#method__ar_periodogram.1">ar_periodogram(x::Array{T, N})</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__ar_periodogram.2">ar_periodogram(x::Array{T, N},  window::AbstractString)</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__ar_periodogram.3">ar_periodogram(x::Array{T, N},  window::AbstractString,  window_len::Int64)</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__autocovariance.1">autocovariance(arma::QuantEcon.ARMA)</a>  Compute the autocovariance function from the ARMA parameters</p>
<p><a href="QuantEcon/#method__b_operator.1">b_operator(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  The D operator, mapping P into</p>
<p><a href="QuantEcon/#method__bellman_operator.1">bellman_operator!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real})</a>  Apply the Bellman operator using <code>v=ddpr.v</code>, <code>Tv=ddpr.Tv</code>, and <code>sigma=ddpr.sigma</code></p>
<p><a href="QuantEcon/#method__bellman_operator.2">bellman_operator!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  v::Array{T, 1},  Tv::Array{T, 1},  sigma::Array{T, 1})</a>  The Bellman operator, which computes and returns the updated value function Tv</p>
<p><a href="QuantEcon/#method__bellman_operator.3">bellman_operator!{T&lt;:AbstractFloat}(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  v::Array{T&lt;:AbstractFloat, 1},  sigma::Array{T, 1})</a>  The Bellman operator, which computes and returns the updated value function Tv</p>
<p><a href="QuantEcon/#method__bellman_operator.4">bellman_operator(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  v::Array{T, 1})</a>  The Bellman operator, which computes and returns the updated value function Tv</p>
<p><a href="QuantEcon/#method__compute_deterministic_entropy.1">compute_deterministic_entropy(rlq::QuantEcon.RBLQ,  F,  K,  x0)</a>  Given <code>K</code> and <code>F</code>, compute the value of deterministic entropy, which is sum_t</p>
<p><a href="QuantEcon/#method__compute_fixed_point.1">compute_fixed_point{TV}(T::Function,  v::TV)</a>  Repeatedly apply a function to search for a fixed point</p>
<p><a href="QuantEcon/#method__compute_greedy.1">compute_greedy!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real})</a>  Compute the v-greedy policy</p>
<p><a href="QuantEcon/#method__compute_sequence.1">compute_sequence(lq::QuantEcon.LQ,  x0::Union{Array{T, N}, T})</a>  Compute and return the optimal state and control sequence, assuming w ~ N(0,1)</p>
<p><a href="QuantEcon/#method__compute_sequence.2">compute_sequence(lq::QuantEcon.LQ,  x0::Union{Array{T, N}, T},  ts_length::Integer)</a>  Compute and return the optimal state and control sequence, assuming w ~ N(0,1)</p>
<p><a href="QuantEcon/#method__d_operator.1">d_operator(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  The D operator, mapping P into</p>
<p><a href="QuantEcon/#method__draw.1">draw(d::QuantEcon.DiscreteRV{TV1&lt;:AbstractArray{T, 1}, TV2&lt;:AbstractArray{T, 1}})</a>  Make a single draw from the discrete distribution</p>
<p><a href="QuantEcon/#method__draw.2">draw(d::QuantEcon.DiscreteRV{TV1&lt;:AbstractArray{T, 1}, TV2&lt;:AbstractArray{T, 1}},  k::Int64)</a>  Make multiple draws from the discrete distribution represented by a</p>
<p><a href="QuantEcon/#method__evaluate_f.1">evaluate_F(rlq::QuantEcon.RBLQ,  F::Array{T, 2})</a>  Given a fixed policy <code>F</code>, with the interpretation u = -F x, this function</p>
<p><a href="QuantEcon/#method__evaluate_policy.1">evaluate_policy(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real})</a>  Method of <code>evaluate_policy</code> that extracts sigma from a <code>DPSolveResult</code></p>
<p><a href="QuantEcon/#method__evaluate_policy.2">evaluate_policy{T&lt;:Integer}(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  sigma::Array{T&lt;:Integer, 1})</a>  Compute the value of a policy.</p>
<p><a href="QuantEcon/#method__gth_solve.1">gth_solve{T&lt;:Integer}(a::AbstractArray{T&lt;:Integer, 2})</a>  solve x(P-I)=0 using an algorithm presented by Grassmann-Taksar-Heyman (GTH)</p>
<p><a href="QuantEcon/#method__impulse_response.1">impulse_response(arma::QuantEcon.ARMA)</a>  Get the impulse response corresponding to our model.</p>
<p><a href="QuantEcon/#method__lae_est.1">lae_est{T}(l::QuantEcon.LAE,  y::AbstractArray{T, N})</a>  A vectorized function that returns the value of the look ahead estimate at the</p>
<p><a href="QuantEcon/#method__m_quadratic_sum.1">m_quadratic_sum(A::Array{T, 2},  B::Array{T, 2})</a>  Computes the quadratic sum</p>
<p><a href="QuantEcon/#method__mc_compute_stationary.1">mc_compute_stationary{T}(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}})</a>  calculate the stationary distributions associated with a N-state markov chain</p>
<p><a href="QuantEcon/#method__n_states.1">n_states(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}})</a>  Number of states in the markov chain <code>mc</code></p>
<p><a href="QuantEcon/#method__nnash.1">nnash(a,  b1,  b2,  r1,  r2,  q1,  q2,  s1,  s2,  w1,  w2,  m1,  m2)</a>  Compute the limit of a Nash linear quadratic dynamic game.</p>
<p><a href="QuantEcon/#method__random_discrete_dp.1">random_discrete_dp(num_states::Integer,  num_actions::Integer)</a>  Generate a DiscreteDP randomly. The reward values are drawn from the normal</p>
<p><a href="QuantEcon/#method__random_discrete_dp.2">random_discrete_dp(num_states::Integer,  num_actions::Integer,  beta::Union{Real, Void})</a>  Generate a DiscreteDP randomly. The reward values are drawn from the normal</p>
<p><a href="QuantEcon/#method__random_markov_chain.1">random_markov_chain(n::Integer)</a>  Return a randomly sampled MarkovChain instance with n states.</p>
<p><a href="QuantEcon/#method__random_markov_chain.2">random_markov_chain(n::Integer,  k::Integer)</a>  Return a randomly sampled MarkovChain instance with n states, where each state</p>
<p><a href="QuantEcon/#method__random_stochastic_matrix.1">random_stochastic_matrix(n::Integer)</a>  Return a randomly sampled n x n stochastic matrix with k nonzero entries for</p>
<p><a href="QuantEcon/#method__random_stochastic_matrix.2">random_stochastic_matrix(n::Integer,  k::Union{Integer, Void})</a>  Return a randomly sampled n x n stochastic matrix with k nonzero entries for</p>
<p><a href="QuantEcon/#method__recurrent_classes.1">recurrent_classes(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}})</a>  Find the recurrent classes of the <code>MarkovChain</code></p>
<p><a href="QuantEcon/#method__robust_rule.1">robust_rule(rlq::QuantEcon.RBLQ)</a>  Solves the robust control problem.</p>
<p><a href="QuantEcon/#method__robust_rule_simple.1">robust_rule_simple(rlq::QuantEcon.RBLQ)</a>  Solve the robust LQ problem</p>
<p><a href="QuantEcon/#method__robust_rule_simple.2">robust_rule_simple(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  Solve the robust LQ problem</p>
<p><a href="QuantEcon/#method__rouwenhorst.1">rouwenhorst(N::Integer,  ρ::Real,  σ::Real)</a>  Rouwenhorst's method to approximate AR(1) processes.</p>
<p><a href="QuantEcon/#method__rouwenhorst.2">rouwenhorst(N::Integer,  ρ::Real,  σ::Real,  μ::Real)</a>  Rouwenhorst's method to approximate AR(1) processes.</p>
<p><a href="QuantEcon/#method__simulate.1">simulate!(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  X::Array{Int64, 2})</a>  Fill <code>X</code> with sample paths of the Markov chain <code>mc</code> as columns.</p>
<p><a href="QuantEcon/#method__simulate.2">simulate(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__simulate.3">simulate(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64,  init::Array{Int64, 1})</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__simulate.4">simulate(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64,  init::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__simulation.1">simulation(arma::QuantEcon.ARMA)</a>  Compute a simulated sample path assuming Gaussian shocks.</p>
<p><a href="QuantEcon/#method__simulation.2">simulation(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__simulation.3">simulation(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64,  init_state::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__smooth.1">smooth(x::Array{T, N})</a>  Version of <code>smooth</code> where <code>window_len</code> and <code>window</code> are keyword arguments</p>
<p><a href="QuantEcon/#method__smooth.2">smooth(x::Array{T, N},  window_len::Int64)</a>  Smooth the data in x using convolution with a window of requested size and type.</p>
<p><a href="QuantEcon/#method__smooth.3">smooth(x::Array{T, N},  window_len::Int64,  window::AbstractString)</a>  Smooth the data in x using convolution with a window of requested size and type.</p>
<p><a href="QuantEcon/#method__solve_discrete_lyapunov.1">solve_discrete_lyapunov(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T})</a>  Solves the discrete lyapunov equation.</p>
<p><a href="QuantEcon/#method__solve_discrete_lyapunov.2">solve_discrete_lyapunov(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  max_it::Int64)</a>  Solves the discrete lyapunov equation.</p>
<p><a href="QuantEcon/#method__solve_discrete_riccati.1">solve_discrete_riccati(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T})</a>  Solves the discrete-time algebraic Riccati equation</p>
<p><a href="QuantEcon/#method__solve_discrete_riccati.2">solve_discrete_riccati(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  N::Union{Array{T, N}, T})</a>  Solves the discrete-time algebraic Riccati equation</p>
<p><a href="QuantEcon/#method__solve.1">solve{Algo&lt;:QuantEcon.DDPAlgorithm, T}(ddp::QuantEcon.DiscreteDP{T, NQ, NR, Tbeta&lt;:Real, Tind},  method::Type{Algo&lt;:QuantEcon.DDPAlgorithm})</a>  Solve the dynamic programming problem.</p>
<p><a href="QuantEcon/#method__solve.2">solve{T}(ddp::QuantEcon.DiscreteDP{T, NQ, NR, Tbeta&lt;:Real, Tind})</a>  Solve the dynamic programming problem.</p>
<p><a href="QuantEcon/#method__spectral_density.1">spectral_density(arma::QuantEcon.ARMA)</a>  Compute the spectral density function.</p>
<p><a href="QuantEcon/#method__stationary_values.1">stationary_values!(lq::QuantEcon.LQ)</a>  Computes value and policy functions in infinite horizon model</p>
<p><a href="QuantEcon/#method__stationary_values.2">stationary_values(lq::QuantEcon.LQ)</a>  Non-mutating routine for solving for <code>P</code>, <code>d</code>, and <code>F</code> in infinite horizon model</p>
<p><a href="QuantEcon/#method__tauchen.1">tauchen(N::Integer,  ρ::Real,  σ::Real)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__tauchen.2">tauchen(N::Integer,  ρ::Real,  σ::Real,  μ::Real)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__tauchen.3">tauchen(N::Integer,  ρ::Real,  σ::Real,  μ::Real,  n_std::Integer)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__update_values.1">update_values!(lq::QuantEcon.LQ)</a>  Update <code>P</code> and <code>d</code> from the value function representation in finite horizon case</p>
<p><a href="QuantEcon/#method__value_simulation.1">value_simulation(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__value_simulation.2">value_simulation(mc::QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}},  ts_length::Int64,  init_state::Int64)</a>  Simulate time series of state transitions of the Markov chain <code>mc</code>.</p>
<p><a href="QuantEcon/#method__var_quadratic_sum.1">var_quadratic_sum(A::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  H::Union{Array{T, N}, T},  bet::Real,  x0::Union{Array{T, N}, T})</a>  Computes the expected discounted quadratic sum</p>
<hr />
<h2 id="types-exported">Types [Exported]</h2>
<p><a href="QuantEcon/#type__arma.1">QuantEcon.ARMA</a>  Represents a scalar ARMA(p, q) process</p>
<p><a href="QuantEcon/#type__discretedp.1">QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind}</a>  DiscreteDP type for specifying paramters for discrete dynamic programming model</p>
<p><a href="QuantEcon/#type__discreterv.1">QuantEcon.DiscreteRV{TV1&lt;:AbstractArray{T, 1}, TV2&lt;:AbstractArray{T, 1}}</a>  Generates an array of draws from a discrete random variable with</p>
<p><a href="QuantEcon/#type__ecdf.1">QuantEcon.ECDF</a>  One-dimensional empirical distribution function given a vector of</p>
<p><a href="QuantEcon/#type__lae.1">QuantEcon.LAE</a>  A look ahead estimator associated with a given stochastic kernel p and a vector</p>
<p><a href="QuantEcon/#type__lq.1">QuantEcon.LQ</a>  Linear quadratic optimal control of either infinite or finite horizon</p>
<p><a href="QuantEcon/#type__markovchain.1">QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}}</a>  Finite-state discrete-time Markov chain.</p>
<p><a href="QuantEcon/#type__rblq.1">QuantEcon.RBLQ</a>  Represents infinite horizon robust LQ control problems of the form</p>
<hr />
<h2 id="methods-internal">Methods [Internal]</h2>
<p><a href="QuantEcon/#method___.1">*{T}(A::Array{T, 3},  v::Array{T, 1})</a>  Define Matrix Multiplication between 3-dimensional matrix and a vector</p>
<p><a href="QuantEcon/#method___compute_sequence.1">_compute_sequence{T}(lq::QuantEcon.LQ,  x0::Array{T, 1},  policies)</a>  Private method implementing <code>compute_sequence</code> when state is a scalar</p>
<p><a href="QuantEcon/#method___compute_sequence.2">_compute_sequence{T}(lq::QuantEcon.LQ,  x0::T,  policies)</a>  Private method implementing <code>compute_sequence</code> when state is a scalar</p>
<p><a href="QuantEcon/#method___generate_a_indptr.1">_generate_a_indptr!(num_states::Int64,  s_indices::Array{T, 1},  out::Array{T, 1})</a>  Generate <code>a_indptr</code>; stored in <code>out</code>. <code>s_indices</code> is assumed to be</p>
<p><a href="QuantEcon/#method___has_sorted_sa_indices.1">_has_sorted_sa_indices(s_indices::Array{T, 1},  a_indices::Array{T, 1})</a>  Check whether <code>s_indices</code> and <code>a_indices</code> are sorted in lexicographic order.</p>
<p><a href="QuantEcon/#method___random_stochastic_matrix.1">_random_stochastic_matrix(n::Integer,  m::Integer)</a>  Generate a "non-square column stochstic matrix" of shape (n, m), which contains</p>
<p><a href="QuantEcon/#method___solve.1">_solve!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{QuantEcon.MPFI, Tval&lt;:Real},  max_iter::Integer,  epsilon::Real,  k::Integer)</a>  Modified Policy Function Iteration</p>
<p><a href="QuantEcon/#method___solve.2">_solve!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{QuantEcon.PFI, Tval&lt;:Real},  max_iter::Integer,  epsilon::Real,  k::Integer)</a>  Policy Function Iteration</p>
<p><a href="QuantEcon/#method___solve.3">_solve!(ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{QuantEcon.VFI, Tval&lt;:Real},  max_iter::Integer,  epsilon::Real,  k::Integer)</a>  Impliments Value Iteration</p>
<p><a href="QuantEcon/#method__call.1">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.2">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.3">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.4">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__call.5">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T},  capT::Union{Int64, Void})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__call.6">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T},  capT::Union{Int64, Void},  rf::Union{Array{T, N}, T})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__call.7">call(::Type{QuantEcon.MarkovChain{T, TM&lt;:AbstractArray{T, 2}, TV&lt;:AbstractArray{T, 1}}},  ddp::QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind},  ddpr::QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real})</a>  Returns the controlled Markov chain for a given policy <code>sigma</code>.</p>
<p><a href="QuantEcon/#method__call.8">call{T, NQ, NR, Tbeta, Tind}(::Type{QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind}},  R::AbstractArray{T, NR},  Q::AbstractArray{T, NQ},  beta::Tbeta,  s_indices::Array{Tind, 1},  a_indices::Array{Tind, 1})</a>  DiscreteDP type for specifying parameters for discrete dynamic programming</p>
<p><a href="QuantEcon/#method__call.9">call{T, NQ, NR, Tbeta}(::Type{QuantEcon.DiscreteDP{T&lt;:Real, NQ, NR, Tbeta&lt;:Real, Tind}},  R::Array{T, NR},  Q::Array{T, NQ},  beta::Tbeta)</a>  DiscreteDP type for specifying parameters for discrete dynamic programming</p>
<p><a href="QuantEcon/#method__random_probvec.1">random_probvec(k::Integer,  m::Integer)</a>  Return m randomly sampled probability vectors of size k.</p>
<p><a href="QuantEcon/#method__s_wise_max.1">s_wise_max!(a_indices::Array{T, 1},  a_indptr::Array{T, 1},  vals::Array{T, 1},  out::Array{T, 1})</a>  Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a</p>
<p><a href="QuantEcon/#method__s_wise_max.2">s_wise_max!(a_indices::Array{T, 1},  a_indptr::Array{T, 1},  vals::Array{T, 1},  out::Array{T, 1},  out_argmax::Array{T, 1})</a>  Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a</p>
<p><a href="QuantEcon/#method__s_wise_max.3">s_wise_max!(vals::AbstractArray{T, 2},  out::Array{T, 1})</a>  Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a</p>
<p><a href="QuantEcon/#method__s_wise_max.4">s_wise_max!(vals::AbstractArray{T, 2},  out::Array{T, 1},  out_argmax::Array{T, 1})</a>  Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a</p>
<p><a href="QuantEcon/#method__s_wise_max.5">s_wise_max(vals::AbstractArray{T, 2})</a>  Return the <code>Vector</code> <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a</p>
<hr />
<h2 id="types-internal">Types [Internal]</h2>
<p><a href="QuantEcon/#type__dpsolveresult.1">QuantEcon.DPSolveResult{Algo&lt;:QuantEcon.DDPAlgorithm, Tval&lt;:Real}</a>  DPSolveResult is an object for retaining results and associated metadata after</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
