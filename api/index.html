<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Spencer Lyon">
        
        <link rel="shortcut icon" href="../../favicon.ico">
        

	<title>Overview - QuantEcon.jl</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/github.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-64434120-1', 'auto');
            ga('send', 'pageview');
        </script>
        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">QuantEcon.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Overview</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Docs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="QuantEcon/">QuantEcon</a>
</li>

                        
                            
<li >
    <a href="QuantEcon.Models/">Models</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="QuantEcon/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/QuantEcon/QuantEcon.jl/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#api-index">API-INDEX</a></li>
        
            <li><a href="#module-quantecon">MODULE: QuantEcon</a></li>
        
            <li><a href="#functions-exported">Functions [Exported]</a></li>
        
            <li><a href="#methods-exported">Methods [Exported]</a></li>
        
            <li><a href="#types-exported">Types [Exported]</a></li>
        
            <li><a href="#methods-internal">Methods [Internal]</a></li>
        
            <li><a href="#module-quanteconmodels">MODULE: QuantEcon.Models</a></li>
        
            <li><a href="#functions-exported_1">Functions [Exported]</a></li>
        
            <li><a href="#methods-exported_1">Methods [Exported]</a></li>
        
            <li><a href="#types-exported_1">Types [Exported]</a></li>
        
            <li><a href="#methods-internal_1">Methods [Internal]</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="api-index">API-INDEX</h1>
<h2 id="module-quantecon">MODULE: QuantEcon</h2>
<hr />
<h2 id="functions-exported">Functions [Exported]</h2>
<p><a href="QuantEcon/#function__do_quad.1">QuantEcon.do_quad</a>  Approximate the integral of <code>f</code>, given quadrature <code>nodes</code> and <code>weights</code></p>
<p><a href="QuantEcon/#function__ecdf.1">QuantEcon.ecdf</a>  Evaluate the empirical cdf at one or more points</p>
<p><a href="QuantEcon/#function__periodogram.1">QuantEcon.periodogram</a>  Computes the periodogram</p>
<hr />
<h2 id="methods-exported">Methods [Exported]</h2>
<p><a href="QuantEcon/#method__f_to_k.1">F_to_K(rlq::QuantEcon.RBLQ,  F::Array{T, 2})</a>  Compute agent 2's best cost-minimizing response <code>K</code>, given <code>F</code>.</p>
<p><a href="QuantEcon/#method__k_to_f.1">K_to_F(rlq::QuantEcon.RBLQ,  K::Array{T, 2})</a>  Compute agent 1's best cost-minimizing response <code>K</code>, given <code>F</code>.</p>
<p><a href="QuantEcon/#method__ar_periodogram.1">ar_periodogram(x::Array{T, N})</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__ar_periodogram.2">ar_periodogram(x::Array{T, N},  window::AbstractString)</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__ar_periodogram.3">ar_periodogram(x::Array{T, N},  window::AbstractString,  window_len::Int64)</a>  Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring.</p>
<p><a href="QuantEcon/#method__autocovariance.1">autocovariance(arma::QuantEcon.ARMA)</a>  Compute the autocovariance function from the ARMA parameters</p>
<p><a href="QuantEcon/#method__b_operator.1">b_operator(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  The D operator, mapping P into</p>
<p><a href="QuantEcon/#method__compute_deterministic_entropy.1">compute_deterministic_entropy(rlq::QuantEcon.RBLQ,  F,  K,  x0)</a>  Given <code>K</code> and <code>F</code>, compute the value of deterministic entropy, which is sum_t</p>
<p><a href="QuantEcon/#method__compute_fixed_point.1">compute_fixed_point{TV}(T::Function,  v::TV)</a>  Repeatedly apply a function to search for a fixed point</p>
<p><a href="QuantEcon/#method__compute_sequence.1">compute_sequence(lq::QuantEcon.LQ,  x0::Union{Array{T, N}, T})</a>  Compute and return the optimal state and control sequence, assuming w ~ N(0,1)</p>
<p><a href="QuantEcon/#method__compute_sequence.2">compute_sequence(lq::QuantEcon.LQ,  x0::Union{Array{T, N}, T},  ts_length::Integer)</a>  Compute and return the optimal state and control sequence, assuming w ~ N(0,1)</p>
<p><a href="QuantEcon/#method__d_operator.1">d_operator(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  The D operator, mapping P into</p>
<p><a href="QuantEcon/#method__draw.1">draw(d::QuantEcon.DiscreteRV{T&lt;:Real})</a>  Make a single draw from the discrete distribution</p>
<p><a href="QuantEcon/#method__draw.2">draw{T}(d::QuantEcon.DiscreteRV{T},  k::Int64)</a>  Make multiple draws from the discrete distribution represented by a</p>
<p><a href="QuantEcon/#method__evaluate_f.1">evaluate_F(rlq::QuantEcon.RBLQ,  F::Array{T, 2})</a>  Given a fixed policy <code>F</code>, with the interpretation u = -F x, this function</p>
<p><a href="QuantEcon/#method__impulse_response.1">impulse_response(arma::QuantEcon.ARMA)</a>  Get the impulse response corresponding to our model.</p>
<p><a href="QuantEcon/#method__lae_est.1">lae_est{T}(l::QuantEcon.LAE,  y::AbstractArray{T, N})</a>  A vectorized function that returns the value of the look ahead estimate at the</p>
<p><a href="QuantEcon/#method__m_quadratic_sum.1">m_quadratic_sum(A::Array{T, 2},  B::Array{T, 2})</a>  Computes the quadratic sum</p>
<p><a href="QuantEcon/#method__mc_compute_stationary.1">mc_compute_stationary{T}(mc::QuantEcon.MarkovChain{T})</a>  calculate the stationary distributions associated with a N-state markov chain</p>
<p><a href="QuantEcon/#method__mc_sample_path.1">mc_sample_path!(mc::QuantEcon.MarkovChain{T&lt;:Real},  samples::Array{T, N})</a>  Fill <code>samples</code> with samples from the Markov chain <code>mc</code></p>
<p><a href="QuantEcon/#method__mc_sample_path.2">mc_sample_path(mc::QuantEcon.MarkovChain{T&lt;:Real})</a>  Simulate a Markov chain starting from an initial distribution</p>
<p><a href="QuantEcon/#method__mc_sample_path.3">mc_sample_path(mc::QuantEcon.MarkovChain{T&lt;:Real},  init::Array{T, 1})</a>  Simulate a Markov chain starting from an initial distribution</p>
<p><a href="QuantEcon/#method__mc_sample_path.4">mc_sample_path(mc::QuantEcon.MarkovChain{T&lt;:Real},  init::Array{T, 1},  sample_size::Int64)</a>  Simulate a Markov chain starting from an initial distribution</p>
<p><a href="QuantEcon/#method__mc_sample_path.5">mc_sample_path(mc::QuantEcon.MarkovChain{T&lt;:Real},  init::Int64)</a>  Simulate a Markov chain starting from an initial state</p>
<p><a href="QuantEcon/#method__mc_sample_path.6">mc_sample_path(mc::QuantEcon.MarkovChain{T&lt;:Real},  init::Int64,  sample_size::Int64)</a>  Simulate a Markov chain starting from an initial state</p>
<p><a href="QuantEcon/#method__nnash.1">nnash(a,  b1,  b2,  r1,  r2,  q1,  q2,  s1,  s2,  w1,  w2,  m1,  m2)</a>  Compute the limit of a Nash linear quadratic dynamic game.</p>
<p><a href="QuantEcon/#method__pdf.1">pdf(d::QuantEcon.BetaBinomial)</a>  Evaluate the pdf of the distributions at the points 0, 1, ..., k</p>
<p><a href="QuantEcon/#method__random_markov_chain.1">random_markov_chain(n::Integer)</a>  Return a randomly sampled MarkovChain instance with n states.</p>
<p><a href="QuantEcon/#method__random_markov_chain.2">random_markov_chain(n::Integer,  k::Integer)</a>  Return a randomly sampled MarkovChain instance with n states, where each state</p>
<p><a href="QuantEcon/#method__random_stochastic_matrix.1">random_stochastic_matrix(n::Integer)</a>  Return a randomly sampled n x n stochastic matrix.</p>
<p><a href="QuantEcon/#method__random_stochastic_matrix.2">random_stochastic_matrix(n::Integer,  k::Integer)</a>  Return a randomly sampled n x n stochastic matrix with k nonzero entries for</p>
<p><a href="QuantEcon/#method__recurrent_classes.1">recurrent_classes(mc::QuantEcon.MarkovChain{T&lt;:Real})</a>  Find the recurrent classes of the <code>MarkovChain</code></p>
<p><a href="QuantEcon/#method__robust_rule.1">robust_rule(rlq::QuantEcon.RBLQ)</a>  Solves the robust control problem.</p>
<p><a href="QuantEcon/#method__robust_rule_simple.1">robust_rule_simple(rlq::QuantEcon.RBLQ)</a>  Solve the robust LQ problem</p>
<p><a href="QuantEcon/#method__robust_rule_simple.2">robust_rule_simple(rlq::QuantEcon.RBLQ,  P::Array{T, 2})</a>  Solve the robust LQ problem</p>
<p><a href="QuantEcon/#method__rouwenhorst.1">rouwenhorst(N::Integer,  ρ::Real,  σ::Real)</a>  Rouwenhorst's method to approximate AR(1) processes.</p>
<p><a href="QuantEcon/#method__rouwenhorst.2">rouwenhorst(N::Integer,  ρ::Real,  σ::Real,  μ::Real)</a>  Rouwenhorst's method to approximate AR(1) processes.</p>
<p><a href="QuantEcon/#method__simulation.1">simulation(arma::QuantEcon.ARMA)</a>  Compute a simulated sample path assuming Gaussian shocks.</p>
<p><a href="QuantEcon/#method__smooth.1">smooth(x::Array{T, N})</a>  Version of <code>smooth</code> where <code>window_len</code> and <code>window</code> are keyword arguments</p>
<p><a href="QuantEcon/#method__smooth.2">smooth(x::Array{T, N},  window_len::Int64)</a>  Smooth the data in x using convolution with a window of requested size and type.</p>
<p><a href="QuantEcon/#method__smooth.3">smooth(x::Array{T, N},  window_len::Int64,  window::AbstractString)</a>  Smooth the data in x using convolution with a window of requested size and type.</p>
<p><a href="QuantEcon/#method__solve_discrete_lyapunov.1">solve_discrete_lyapunov(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T})</a>  Solves the discrete lyapunov equation.</p>
<p><a href="QuantEcon/#method__solve_discrete_lyapunov.2">solve_discrete_lyapunov(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  max_it::Int64)</a>  Solves the discrete lyapunov equation.</p>
<p><a href="QuantEcon/#method__solve_discrete_riccati.1">solve_discrete_riccati(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T})</a>  Solves the discrete-time algebraic Riccati equation</p>
<p><a href="QuantEcon/#method__solve_discrete_riccati.2">solve_discrete_riccati(A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  N::Union{Array{T, N}, T})</a>  Solves the discrete-time algebraic Riccati equation</p>
<p><a href="QuantEcon/#method__spectral_density.1">spectral_density(arma::QuantEcon.ARMA)</a>  Compute the spectral density function.</p>
<p><a href="QuantEcon/#method__stationary_values.1">stationary_values!(lq::QuantEcon.LQ)</a>  Computes value and policy functions in infinite horizon model</p>
<p><a href="QuantEcon/#method__stationary_values.2">stationary_values(lq::QuantEcon.LQ)</a>  Non-mutating routine for solving for <code>P</code>, <code>d</code>, and <code>F</code> in infinite horizon model</p>
<p><a href="QuantEcon/#method__tauchen.1">tauchen(N::Integer,  ρ::Real,  σ::Real)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__tauchen.2">tauchen(N::Integer,  ρ::Real,  σ::Real,  μ::Real)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__tauchen.3">tauchen(N::Integer,  ρ::Real,  σ::Real,  μ::Real,  n_std::Integer)</a>  Tauchen's (1996) method for approximating AR(1) process with finite markov chain</p>
<p><a href="QuantEcon/#method__update_values.1">update_values!(lq::QuantEcon.LQ)</a>  Update <code>P</code> and <code>d</code> from the value function representation in finite horizon case</p>
<p><a href="QuantEcon/#method__var_quadratic_sum.1">var_quadratic_sum(A::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  H::Union{Array{T, N}, T},  bet::Real,  x0::Union{Array{T, N}, T})</a>  Computes the expected discounted quadratic sum</p>
<hr />
<h2 id="types-exported">Types [Exported]</h2>
<p><a href="QuantEcon/#type__arma.1">QuantEcon.ARMA</a>  Represents a scalar ARMA(p, q) process</p>
<p><a href="QuantEcon/#type__betabinomial.1">QuantEcon.BetaBinomial</a>  The Beta-Binomial distribution</p>
<p><a href="QuantEcon/#type__discreterv.1">QuantEcon.DiscreteRV{T&lt;:Real}</a>  Generates an array of draws from a discrete random variable with</p>
<p><a href="QuantEcon/#type__ecdf.1">QuantEcon.ECDF</a>  One-dimensional empirical distribution function given a vector of</p>
<p><a href="QuantEcon/#type__lae.1">QuantEcon.LAE</a>  A look ahead estimator associated with a given stochastic kernel p and a vector</p>
<p><a href="QuantEcon/#type__lq.1">QuantEcon.LQ</a>  Linear quadratic optimal control of either infinite or finite horizon</p>
<p><a href="QuantEcon/#type__markovchain.1">QuantEcon.MarkovChain{T&lt;:Real}</a>  Finite-state discrete-time Markov chain.</p>
<p><a href="QuantEcon/#type__rblq.1">QuantEcon.RBLQ</a>  Represents infinite horizon robust LQ control problems of the form</p>
<hr />
<h2 id="methods-internal">Methods [Internal]</h2>
<p><a href="QuantEcon/#method___compute_sequence.1">_compute_sequence{T}(lq::QuantEcon.LQ,  x0::Array{T, 1},  policies)</a>  Private method implementing <code>compute_sequence</code> when state is a scalar</p>
<p><a href="QuantEcon/#method___compute_sequence.2">_compute_sequence{T}(lq::QuantEcon.LQ,  x0::T,  policies)</a>  Private method implementing <code>compute_sequence</code> when state is a scalar</p>
<p><a href="QuantEcon/#method__call.1">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.2">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.3">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T})</a>  Version of default constuctor making <code>bet</code> <code>capT</code> <code>rf</code> keyword arguments</p>
<p><a href="QuantEcon/#method__call.4">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__call.5">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T},  capT::Union{Int64, Void})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__call.6">call(::Type{QuantEcon.LQ},  Q::Union{Array{T, N}, T},  R::Union{Array{T, N}, T},  A::Union{Array{T, N}, T},  B::Union{Array{T, N}, T},  C::Union{Array{T, N}, T},  N::Union{Array{T, N}, T},  bet::Union{Array{T, N}, T},  capT::Union{Int64, Void},  rf::Union{Array{T, N}, T})</a>  Main constructor for LQ type</p>
<p><a href="QuantEcon/#method__n_states.1">n_states(mc::QuantEcon.MarkovChain{T&lt;:Real})</a>  Number of states in the markov chain <code>mc</code></p>
<p><a href="QuantEcon/#method__random_probvec.1">random_probvec(k::Integer,  m::Integer)</a>  Return m randomly sampled probability vectors of size k.</p>
<h2 id="module-quanteconmodels">MODULE: QuantEcon.Models</h2>
<hr />
<h2 id="functions-exported_1">Functions [Exported]</h2>
<p><a href="QuantEcon.Models/#function__bellman_operator.1">QuantEcon.Models.bellman_operator</a>  Apply the Bellman operator for a given model and initial value</p>
<p><a href="QuantEcon.Models/#function__bellman_operator.2">QuantEcon.Models.bellman_operator!</a>  Apply the Bellman operator for a given model and initial value</p>
<p><a href="QuantEcon.Models/#function__get_greedy.1">QuantEcon.Models.get_greedy</a>  Extract the greedy policy (policy function) of the model</p>
<p><a href="QuantEcon.Models/#function__get_greedy.2">QuantEcon.Models.get_greedy!</a>  Extract the greedy policy (policy function) of the model</p>
<hr />
<h2 id="methods-exported_1">Methods [Exported]</h2>
<p><a href="QuantEcon.Models/#method__call_option.1">call_option(ap::QuantEcon.Models.AssetPrices,  zet::Real,  p_s::Real)</a>  Computes price of a call option on a consol bond, both finite and infinite</p>
<p><a href="QuantEcon.Models/#method__call_option.2">call_option(ap::QuantEcon.Models.AssetPrices,  zet::Real,  p_s::Real,  T::Array{Int64, 1})</a>  Computes price of a call option on a consol bond, both finite and infinite</p>
<p><a href="QuantEcon.Models/#method__call_option.3">call_option(ap::QuantEcon.Models.AssetPrices,  zet::Real,  p_s::Real,  T::Array{Int64, 1},  epsilon)</a>  Computes price of a call option on a consol bond, both finite and infinite</p>
<p><a href="QuantEcon.Models/#method__coleman_operator.1">coleman_operator!(cp::QuantEcon.Models.ConsumerProblem,  c::Array{T, 2},  out::Array{T, 2})</a>  The approximate Coleman operator.</p>
<p><a href="QuantEcon.Models/#method__coleman_operator.2">coleman_operator(cp::QuantEcon.Models.ConsumerProblem,  c::Array{T, 2})</a>  Apply the Coleman operator for a given model and initial value</p>
<p><a href="QuantEcon.Models/#method__compute_lt_price.1">compute_lt_price(lt::QuantEcon.Models.LucasTree)</a>  Compute the equilibrium price function associated with Lucas tree <code>lt</code></p>
<p><a href="QuantEcon.Models/#method__consol_price.1">consol_price(ap::QuantEcon.Models.AssetPrices,  zet::Real)</a>  Computes price of a consol bond with payoff zeta</p>
<p><a href="QuantEcon.Models/#method__gen_aggregates.1">gen_aggregates(uc::QuantEcon.Models.UncertaintyTrapEcon)</a>  Generate aggregates based on current beliefs (mu, gamma).  This</p>
<p><a href="QuantEcon.Models/#method__lucas_operator.1">lucas_operator(lt::QuantEcon.Models.LucasTree,  f::AbstractArray{T, 1})</a>  The approximate Lucas operator, which computes and returns the updated function</p>
<p><a href="QuantEcon.Models/#method__res_wage_operator.1">res_wage_operator!(sp::QuantEcon.Models.SearchProblem,  phi::Array{T, 1},  out::Array{T, 1})</a>  Updates the reservation wage function guess phi via the operator Q.</p>
<p><a href="QuantEcon.Models/#method__res_wage_operator.2">res_wage_operator(sp::QuantEcon.Models.SearchProblem,  phi::Array{T, 1})</a>  Updates the reservation wage function guess phi via the operator Q.</p>
<p><a href="QuantEcon.Models/#method__tree_price.1">tree_price(ap::QuantEcon.Models.AssetPrices)</a>  Computes the function v such that the price of the lucas tree is v(lambda)C_t</p>
<p><a href="QuantEcon.Models/#method__update_beliefs.1">update_beliefs!(uc::QuantEcon.Models.UncertaintyTrapEcon,  X,  M)</a>  Update beliefs (mu, gamma) based on aggregates X and M.</p>
<p><a href="QuantEcon.Models/#method__vfi.1">vfi!(ae::QuantEcon.Models.ArellanoEconomy)</a>  This performs value function iteration and stores all of the data inside</p>
<hr />
<h2 id="types-exported_1">Types [Exported]</h2>
<p><a href="QuantEcon.Models/#type__arellanoeconomy.1">QuantEcon.Models.ArellanoEconomy</a>  Arellano 2008 deals with a small open economy whose government</p>
<p><a href="QuantEcon.Models/#type__assetprices.1">QuantEcon.Models.AssetPrices</a>  A class to compute asset prices when the endowment follows a finite Markov chain</p>
<p><a href="QuantEcon.Models/#type__careerworkerproblem.1">QuantEcon.Models.CareerWorkerProblem</a>  Career/job choice model fo Derek Neal (1999)</p>
<p><a href="QuantEcon.Models/#type__consumerproblem.1">QuantEcon.Models.ConsumerProblem</a>  Income fluctuation problem</p>
<p><a href="QuantEcon.Models/#type__growthmodel.1">QuantEcon.Models.GrowthModel</a>  Neoclassical growth model</p>
<p><a href="QuantEcon.Models/#type__jvworker.1">QuantEcon.Models.JvWorker</a>  A Jovanovic-type model of employment with on-the-job search.</p>
<p><a href="QuantEcon.Models/#type__lucastree.1">QuantEcon.Models.LucasTree</a>  The Lucas asset pricing model</p>
<p><a href="QuantEcon.Models/#type__searchproblem.1">QuantEcon.Models.SearchProblem</a>  Unemployment/search problem where offer distribution is unknown</p>
<hr />
<h2 id="methods-internal_1">Methods [Internal]</h2>
<p><a href="QuantEcon.Models/#method__call.1">call(::Type{QuantEcon.Models.ArellanoEconomy})</a>  This is the default constructor for building an economy as presented</p>
<p><a href="QuantEcon.Models/#method__call.2">call(::Type{QuantEcon.Models.AssetPrices},  bet::Real,  P::Array{T, 2},  s::Array{T, 1},  gamm::Real)</a>  Construct an instance of <code>AssetPrices</code>, where <code>n</code>, <code>P_tilde</code>, and <code>P_check</code> are</p>
<p><a href="QuantEcon.Models/#method__call.3">call(::Type{QuantEcon.Models.GrowthModel})</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.4">call(::Type{QuantEcon.Models.GrowthModel},  f)</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.5">call(::Type{QuantEcon.Models.GrowthModel},  f,  bet)</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.6">call(::Type{QuantEcon.Models.GrowthModel},  f,  bet,  u)</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.7">call(::Type{QuantEcon.Models.GrowthModel},  f,  bet,  u,  grid_max)</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.8">call(::Type{QuantEcon.Models.GrowthModel},  f,  bet,  u,  grid_max,  grid_size)</a>  Constructor of <code>GrowthModel</code></p>
<p><a href="QuantEcon.Models/#method__call.9">call(::Type{QuantEcon.Models.LucasTree},  gam::Real,  bet::Real,  alpha::Real,  sigma::Real)</a>  Constructor for LucasTree</p>
<p><a href="QuantEcon.Models/#method__compute_prices.1">compute_prices!(ae::QuantEcon.Models.ArellanoEconomy)</a>  This function takes the Arellano economy and its value functions and</p>
<p><a href="QuantEcon.Models/#method__default_du.1">default_du{T&lt;:Real}(x::T&lt;:Real)</a>  Marginal utility for log utility function</p>
<p><a href="QuantEcon.Models/#method__one_step_update.1">one_step_update!(ae::QuantEcon.Models.ArellanoEconomy,  EV::Array{Float64, 2},  EVd::Array{Float64, 2},  EVc::Array{Float64, 2})</a>  This function performs the one step update of the value function for the</p>
<p><a href="QuantEcon.Models/#method__simulate.1">simulate(ae::QuantEcon.Models.ArellanoEconomy)</a>  This function simulates the Arellano economy</p>
<p><a href="QuantEcon.Models/#method__simulate.2">simulate(ae::QuantEcon.Models.ArellanoEconomy,  capT::Int64)</a>  This function simulates the Arellano economy</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
